<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Core\Domain\Repositories\VulnerabilityRepository;
use App\Core\Domain\Repositories\AiFixRepository;
use App\Jobs\GenerateAiFixJob;
use App\Jobs\ScanVulnerabilityJob;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;

class VulnerabilityScannerController extends Controller
{
    public function __construct(
        private VulnerabilityRepository $vulnerabilityRepository,
        private AiFixRepository $aiFixRepository
    ) {}

    /**
     * Scan a repository for vulnerabilities
     */
    public function scanRepository(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'repository_url' => 'required|url',
            'scan_type' => 'in:quick,deep',
            'branch' => 'string|max:255'
        ]);

        try {
            // Clone repository temporarily
            $repoPath = $this->cloneRepository($validated['repository_url'], $validated['branch'] ?? 'main');
            
            // Scan all code files
            $scanResults = $this->scanCodeFiles($repoPath, $validated['scan_type']);
            
            // Store vulnerabilities in database
            foreach ($scanResults['vulnerabilities'] as $vulnerability) {
                $this->vulnerabilityRepository->create([
                    'id' => \Illuminate\Support\Str::uuid(),
                    'repository_id' => null, // Will be set when repository is created
                    'cve_id' => $vulnerability['cve_id'] ?? null,
                    'identifier' => $vulnerability['identifier'],
                    'title' => $vulnerability['title'],
                    'description' => $vulnerability['description'],
                    'severity' => $vulnerability['severity'],
                    'cvss_score' => $vulnerability['cvss_score'] ?? null,
                    'cvss_vector' => $vulnerability['cvss_vector'] ?? null,
                    'location' => $vulnerability['location'],
                    'status' => 'detected',
                    'metadata' => $vulnerability['metadata'] ?? [],
                    'detected_at' => now(),
                ]);
            }

            // Cleanup temporary repository
            $this->cleanupRepository($repoPath);

            return response()->json([
                'message' => 'Repository scan completed',
                'scan_id' => $scanResults['scan_id'],
                'vulnerabilities_found' => count($scanResults['vulnerabilities']),
                'scan_type' => $validated['scan_type'],
                'scan_duration' => $scanResults['duration']
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Repository scan failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Scan uploaded code files
     */
    public function scanFiles(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'files' => 'required|array|max:10',
            'files.*' => 'file|max:10240', // Max 10MB per file
            'scan_type' => 'in:quick,deep'
        ]);

        try {
            $scanResults = [];
            $totalVulnerabilities = 0;

            foreach ($validated['files'] as $file) {
                $content = file_get_contents($file->getPathname());
                $result = $this->sendToAiService($content, $file->getClientOriginalName(), $validated['scan_type']);
                
                $scanResults[] = $result;
                
                // Store vulnerabilities
                if (isset($result['vulnerability_analysis']['vulnerabilities'])) {
                    foreach ($result['vulnerability_analysis']['vulnerabilities'] as $vulnerability) {
                        $this->vulnerabilityRepository->create([
                            'id' => \Illuminate\Support\Str::uuid(),
                            'repository_id' => null,
                            'cve_id' => $vulnerability['cve_id'] ?? null,
                            'identifier' => $vulnerability['type'] ?? 'unknown',
                            'title' => $vulnerability['type'] ?? 'Unknown Vulnerability',
                            'description' => $vulnerability['description'] ?? 'No description available',
                            'severity' => $this->mapSeverity($vulnerability['severity_score'] ?? 0),
                            'cvss_score' => $vulnerability['severity_score'] ?? null,
                            'cvss_vector' => $vulnerability['cvss_vector'] ?? null,
                            'location' => [
                                'file' => $result['file_name'] ?? 'unknown',
                                'line' => $vulnerability['line_number'] ?? null,
                                'column' => $vulnerability['column'] ?? null,
                                'code_snippet' => $vulnerability['code_snippet'] ?? null
                            ],
                            'status' => 'detected',
                            'metadata' => [
                                'detection_method' => $vulnerability['detection_method'] ?? 'unknown',
                                'matched_pattern' => $vulnerability['matched_pattern'] ?? null,
                                'recommendation' => $vulnerability['recommendation'] ?? null
                            ],
                            'detected_at' => now(),
                        ]);
                        $totalVulnerabilities++;
                    }
                }
            }

            return response()->json([
                'message' => 'File scan completed',
                'files_scanned' => count($validated['files']),
                'vulnerabilities_found' => $totalVulnerabilities,
                'scan_results' => $scanResults
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'File scan failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generate AI fix for vulnerability
     */
    public function generateFix(Request $request, string $id): JsonResponse
    {
        $vulnerability = $this->vulnerabilityRepository->findById($id);
        
        if (!$vulnerability) {
            return response()->json(['error' => 'Vulnerability not found'], 404);
        }

        try {
            // Get the vulnerable code
            $codeContent = $this->getVulnerableCode($vulnerability);
            
            // Send to AI service for fix generation
            $fixResult = $this->sendToAiFixService($codeContent, $vulnerability->identifier);
            
            // Store the AI fix
            $this->aiFixRepository->create([
                'id' => \Illuminate\Support\Str::uuid(),
                'vulnerability_id' => $vulnerability->id,
                'fixed_code' => $fixResult['fixed_code'],
                'confidence_score' => $fixResult['confidence'],
                'explanation' => $fixResult['explanation'],
                'recommendations' => $fixResult['recommendations'] ?? [],
                'status' => 'generated',
                'repository_id' => $vulnerability->repository_id
            ]);

            // Update vulnerability status
            $this->vulnerabilityRepository->update($id, ['status' => 'fixing']);

            return response()->json([
                'message' => 'AI fix generated successfully',
                'fix_id' => $fixResult['fix_id'],
                'confidence' => $fixResult['confidence'],
                'recommendations' => $fixResult['recommendations']
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'AI fix generation failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Apply AI fix to codebase
     */
    public function applyFix(Request $request, string $id): JsonResponse
    {
        $validated = $request->validate([
            'fix_id' => 'required|uuid',
            'create_pull_request' => 'boolean'
        ]);

        $vulnerability = $this->vulnerabilityRepository->findById($id);
        $fix = $this->aiFixRepository->findById($validated['fix_id']);

        if (!$vulnerability || !$fix) {
            return response()->json(['error' => 'Vulnerability or fix not found'], 404);
        }

        try {
            // Apply the fix to the codebase
            $result = $this->applyFixToCodebase($vulnerability, $fix);
            
            if ($validated['create_pull_request']) {
                // Create pull request
                $prUrl = $this->createPullRequest($vulnerability, $fix, $result);
                $result['pull_request_url'] = $prUrl;
            }

            // Update vulnerability status
            $this->vulnerabilityRepository->update($id, [
                'status' => 'fixed',
                'fixed_at' => now()
            ]);

            // Update fix status
            $this->aiFixRepository->update($validated['fix_id'], ['status' => 'applied']);

            return response()->json([
                'message' => 'Fix applied successfully',
                'result' => $result
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Fix application failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get vulnerability statistics
     */
    public function statistics(): JsonResponse
    {
        $stats = $this->vulnerabilityRepository->getStatistics();
        
        return response()->json([
            'total_vulnerabilities' => $stats['total'],
            'by_severity' => $stats['by_severity'],
            'by_status' => $stats['by_status'],
            'recent_detections' => $stats['recent'],
            'trend' => $stats['trend']
        ]);
    }

    /**
     * Scan repository using Semgrep (professional vulnerability scanner)
     */
    public function scanWithSemgrep(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'repository_url' => 'required|url',
            'repository_id' => 'nullable|uuid',
            'branch' => 'nullable|string|max:255',
            'github_token' => 'nullable|string',
            'rules' => 'nullable|string',
            'analyze_false_positives' => 'nullable|boolean'
        ]);

        try {
            $response = Http::timeout(600)->post(
                config('services.ai_service.url') . '/api/semgrep/scan',
                [
                    'repo_url' => $validated['repository_url'],
                    'branch' => $validated['branch'] ?? 'main',
                    'github_token' => $validated['github_token'] ?? null,
                    'rules' => $validated['rules'] ?? null,
                    'analyze_false_positives' => $validated['analyze_false_positives'] ?? false
                ]
            );

            if (!$response->successful()) {
                return response()->json([
                    'error' => 'Semgrep scan failed',
                    'message' => $response->body()
                ], $response->status());
            }

            $scanResults = $response->json();
            $vulnerabilitiesStored = 0;

            // Store vulnerabilities in database
            if (isset($scanResults['findings'])) {
                foreach ($scanResults['findings'] as $finding) {
                    $this->vulnerabilityRepository->create([
                        'id' => \Illuminate\Support\Str::uuid(),
                        'repository_id' => $validated['repository_id'] ?? null,
                        'source' => 'semgrep',
                        'rule_id' => $finding['type'] ?? null,
                        'identifier' => $finding['type'] ?? 'unknown',
                        'title' => $finding['message'] ?? 'Security Finding',
                        'description' => $finding['message'] ?? '',
                        'severity' => $finding['severity'] ?? 'medium',
                        'cvss_score' => null,
                        'cvss_vector' => null,
                        'location' => [
                            'file' => $finding['file'] ?? '',
                            'line' => $finding['line'] ?? null,
                            'end_line' => $finding['end_line'] ?? null,
                            'column' => $finding['column'] ?? null
                        ],
                        'status' => 'detected',
                        'metadata' => [
                            'cwe' => $finding['cwe'] ?? null,
                            'owasp' => $finding['owasp'] ?? null,
                            'semgrep_metadata' => $finding['metadata'] ?? [],
                            'semgrep_extra' => $finding['extra'] ?? []
                        ],
                        'confidence_score' => $finding['confidence'] ?? null,
                        'fix_suggestion' => $finding['suggested_fix'] ?? null,
                        'is_false_positive' => $finding['is_false_positive'] ?? false,
                        'false_positive_reason' => $finding['false_positive_reason'] ?? null,
                        'scan_id' => $scanResults['scan_id'] ?? null,
                        'detected_at' => now(),
                    ]);
                    $vulnerabilitiesStored++;
                }
            }

            return response()->json([
                'message' => 'Semgrep scan completed',
                'scan_id' => $scanResults['scan_id'] ?? null,
                'repository' => $scanResults['repository'] ?? $validated['repository_url'],
                'branch' => $scanResults['branch'] ?? $validated['branch'] ?? 'main',
                'total_findings' => $scanResults['total_findings'] ?? 0,
                'vulnerabilities_stored' => $vulnerabilitiesStored,
                'by_severity' => $scanResults['by_severity'] ?? [],
                'risk_score' => $scanResults['risk_score'] ?? 0,
                'scan_duration' => $scanResults['scan_duration_seconds'] ?? null,
                'status' => $scanResults['status'] ?? 'completed'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Semgrep scan failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Analyze a single finding with Claude for false positive detection
     */
    public function analyzeFindingWithClaude(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'code_snippet' => 'required|string',
            'finding_type' => 'required|string',
            'file_path' => 'required|string',
            'line_number' => 'required|integer'
        ]);

        try {
            $response = Http::timeout(60)->post(
                config('services.ai_service.url') . '/api/semgrep/analyze-finding',
                $validated
            );

            if (!$response->successful()) {
                return response()->json([
                    'error' => 'Analysis failed',
                    'message' => $response->body()
                ], $response->status());
            }

            return response()->json($response->json());

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Analysis failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    private function mapSeverity(float $severityScore): string
    {
        if ($severityScore >= 9.0) {
            return 'critical';
        } elseif ($severityScore >= 7.0) {
            return 'high';
        } elseif ($severityScore >= 4.0) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    private function cloneRepository(string $url, string $branch): string
    {
        // Validate URL format
        if (!filter_var($url, FILTER_VALIDATE_URL) && !preg_match('/^[a-zA-Z0-9\-\_\.]+\/[a-zA-Z0-9\-\_\.]+$/', $url)) {
            throw new \Exception("Invalid repository URL format");
        }
        
        // Sanitize inputs
        $branch = preg_replace('/[^a-zA-Z0-9\-\_]/', '', trim($branch));
        if (empty($branch)) {
            $branch = 'main';
        }
        
        $repoName = preg_replace('/[^a-zA-Z0-9\-\_]/', '', basename($url, '.git'));
        if (empty($repoName)) {
            throw new \Exception("Invalid repository name");
        }
        
        $repoPath = storage_path("app/temp/repos/{$repoName}_" . time());
        
        // Create directory if it doesn't exist
        if (!is_dir(dirname($repoPath))) {
            mkdir(dirname($repoPath), 0755, true);
        }
        
        // Clone repository using Process component (safe from injection)
        $process = new \Symfony\Component\Process\Process([
            'git', 'clone', '--branch', $branch, '--depth', '1', $url, $repoPath
        ]);
        
        try {
            $process->run();
            
            if (!$process->isSuccessful()) {
                throw new \Exception("Failed to clone repository: " . $process->getErrorOutput());
            }
        } catch (\Symfony\Component\Process\Exception\ProcessFailedException $e) {
            throw new \Exception("Failed to clone repository: " . $e->getMessage());
        }
        
        return $repoPath;
    }

    private function scanCodeFiles(string $repoPath, string $scanType): array
    {
        $startTime = microtime(true);
        $vulnerabilities = [];
        $scanId = \Illuminate\Support\Str::uuid();
        
        // Find all code files
        $files = $this->findCodeFiles($repoPath);
        
        foreach ($files as $file) {
            $content = file_get_contents($file);
            $relativePath = str_replace($repoPath . '/', '', $file);
            
            // Send to AI service for scanning
            $result = $this->sendToAiService($content, $relativePath, $scanType);
            
            if (isset($result['vulnerability_analysis']['vulnerabilities'])) {
                foreach ($result['vulnerability_analysis']['vulnerabilities'] as $vulnerability) {
                    $vulnerability['file_path'] = $relativePath;
                    $vulnerabilities[] = $vulnerability;
                }
            }
        }
        
        return [
            'scan_id' => $scanId,
            'vulnerabilities' => $vulnerabilities,
            'duration' => round(microtime(true) - $startTime, 2)
        ];
    }

    private function findCodeFiles(string $path): array
    {
        $files = [];
        $extensions = ['php', 'js', 'ts', 'vue', 'py', 'java', 'cpp', 'c', 'h', 'go', 'rs'];
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($path),
            \RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), $extensions)) {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }

    private function sendToAiService(string $content, string $filename, string $scanType): array
    {
        // Create temporary file for the AI service
        $tempFile = tempnam(sys_get_temp_dir(), 'devguardian_scan_');
        file_put_contents($tempFile, $content);
        
        $response = Http::timeout(60)->attach(
            'file', file_get_contents($tempFile), $filename
        )->post(
            config('services.ai_service.url') . '/api/security/scan',
            [
                'scan_type' => $scanType
            ]
        );
        
        // Clean up temporary file
        unlink($tempFile);
        
        if (!$response->successful()) {
            throw new \Exception('AI service scan failed: ' . $response->body());
        }
        
        return $response->json();
    }

    private function sendToAiFixService(string $content, string $vulnerabilityType): array
    {
        // Create temporary file for the AI fix service
        $tempFile = tempnam(sys_get_temp_dir(), 'devguardian_fix_');
        file_put_contents($tempFile, $content);
        
        $response = Http::timeout(120)->attach(
            'file', file_get_contents($tempFile), 'vulnerable_code.php'
        )->post(
            config('services.ai_service.url') . '/api/ai-fix/generate-fix',
            [
                'vulnerability_type' => $vulnerabilityType
            ]
        );
        
        // Clean up temporary file
        unlink($tempFile);
        
        if (!$response->successful()) {
            throw new \Exception('AI fix service failed: ' . $response->body());
        }
        
        return $response->json();
    }

    private function getVulnerableCode($vulnerability): string
    {
        // Get code snippet from location data
        return $vulnerability->location['code_snippet'] ?? '';
    }

    private function applyFixToCodebase($vulnerability, $fix): array
    {
        $filePath = $vulnerability->location['path'] ?? '';
        if (!file_exists($filePath)) {
            throw new \Exception('Source file not found');
        }
        
        // Backup original file
        $backupPath = $filePath . '.backup.' . date('Y-m-d-H-i-s');
        copy($filePath, $backupPath);
        
        // Apply fix
        file_put_contents($filePath, $fix->fixed_code);
        
        return [
            'file_path' => $filePath,
            'backup_path' => $backupPath,
            'fix_applied' => true
        ];
    }

    private function createPullRequest($vulnerability, $fix, $result): string
    {
        // Mock implementation - integrate with GitHub/GitLab APIs
        $prTitle = "Fix: {$vulnerability->title}";
        $prDescription = "Automated fix for vulnerability {$vulnerability->id}\n\n" .
                        "**AI Confidence:** {$fix->confidence}%\n\n" .
                        "**Explanation:** {$fix->explanation}\n\n" .
                        "**Recommendations:**\n" . implode("\n", $fix->recommendations);
        
        // Return mock PR URL
        return "https://github.com/example/repo/pull/123";
    }

    private function cleanupRepository(string $repoPath): void
    {
        // Validate path is within allowed directory
        $baseDir = storage_path('app/temp/repos');
        $realPath = realpath($repoPath);
        $realBaseDir = realpath($baseDir);
        
        if ($realPath && $realBaseDir && str_starts_with($realPath, $realBaseDir)) {
            $this->safeDeleteDirectory($realPath);
        }
    }
    
    private function safeDeleteDirectory(string $path): bool
    {
        if (!is_dir($path)) {
            return false;
        }
        
        $items = array_diff(scandir($path), ['.', '..']);
        foreach ($items as $item) {
            $itemPath = $path . DIRECTORY_SEPARATOR . $item;
            if (is_dir($itemPath)) {
                $this->safeDeleteDirectory($itemPath);
            } else {
                unlink($itemPath);
            }
        }
        
        return rmdir($path);
    }
}
