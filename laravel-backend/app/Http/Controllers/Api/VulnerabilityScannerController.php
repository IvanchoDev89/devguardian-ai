<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Core\Domain\Repositories\VulnerabilityRepository;
use App\Core\Domain\Repositories\AiFixRepository;
use App\Jobs\GenerateAiFixJob;
use App\Jobs\ScanVulnerabilityJob;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;

class VulnerabilityScannerController extends Controller
{
    public function __construct(
        private VulnerabilityRepository $vulnerabilityRepository,
        private AiFixRepository $aiFixRepository
    ) {}

    /**
     * Scan a repository for vulnerabilities
     */
    public function scanRepository(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'repository_url' => 'required|url',
            'scan_type' => 'in:quick,deep',
            'branch' => 'string|max:255'
        ]);

        try {
            // Clone repository temporarily
            $repoPath = $this->cloneRepository($validated['repository_url'], $validated['branch'] ?? 'main');
            
            // Scan all code files
            $scanResults = $this->scanCodeFiles($repoPath, $validated['scan_type']);
            
            // Store vulnerabilities in database
            foreach ($scanResults['vulnerabilities'] as $vulnerability) {
                $this->vulnerabilityRepository->create([
                    'id' => \Illuminate\Support\Str::uuid(),
                    'repository_id' => null, // Will be set when repository is created
                    'cve_id' => $vulnerability['cve_id'] ?? null,
                    'identifier' => $vulnerability['identifier'],
                    'title' => $vulnerability['title'],
                    'description' => $vulnerability['description'],
                    'severity' => $vulnerability['severity'],
                    'cvss_score' => $vulnerability['cvss_score'] ?? null,
                    'cvss_vector' => $vulnerability['cvss_vector'] ?? null,
                    'location' => $vulnerability['location'],
                    'status' => 'detected',
                    'metadata' => $vulnerability['metadata'] ?? [],
                    'detected_at' => now(),
                ]);
            }

            // Cleanup temporary repository
            $this->cleanupRepository($repoPath);

            return response()->json([
                'message' => 'Repository scan completed',
                'scan_id' => $scanResults['scan_id'],
                'vulnerabilities_found' => count($scanResults['vulnerabilities']),
                'scan_type' => $validated['scan_type'],
                'scan_duration' => $scanResults['duration']
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Repository scan failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Scan uploaded code files
     */
    public function scanFiles(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'files' => 'required|array|max:10',
            'files.*' => 'file|max:10240', // Max 10MB per file
            'scan_type' => 'in:quick,deep'
        ]);

        try {
            $scanResults = [];
            $totalVulnerabilities = 0;

            foreach ($validated['files'] as $file) {
                $content = file_get_contents($file->getPathname());
                $result = $this->sendToAiService($content, $file->getClientOriginalName(), $validated['scan_type']);
                
                $scanResults[] = $result;
                
                // Store vulnerabilities
                if (isset($result['vulnerability_analysis']['vulnerabilities'])) {
                    foreach ($result['vulnerability_analysis']['vulnerabilities'] as $vulnerability) {
                        $this->vulnerabilityRepository->create([
                            'id' => \Illuminate\Support\Str::uuid(),
                            'repository_id' => null,
                            'cve_id' => $vulnerability['cve_id'] ?? null,
                            'identifier' => $vulnerability['type'] ?? 'unknown',
                            'title' => $vulnerability['type'] ?? 'Unknown Vulnerability',
                            'description' => $vulnerability['description'] ?? 'No description available',
                            'severity' => $this->mapSeverity($vulnerability['severity_score'] ?? 0),
                            'cvss_score' => $vulnerability['severity_score'] ?? null,
                            'cvss_vector' => $vulnerability['cvss_vector'] ?? null,
                            'location' => [
                                'file' => $result['file_name'] ?? 'unknown',
                                'line' => $vulnerability['line_number'] ?? null,
                                'column' => $vulnerability['column'] ?? null,
                                'code_snippet' => $vulnerability['code_snippet'] ?? null
                            ],
                            'status' => 'detected',
                            'metadata' => [
                                'detection_method' => $vulnerability['detection_method'] ?? 'unknown',
                                'matched_pattern' => $vulnerability['matched_pattern'] ?? null,
                                'recommendation' => $vulnerability['recommendation'] ?? null
                            ],
                            'detected_at' => now(),
                        ]);
                        $totalVulnerabilities++;
                    }
                }
            }

            return response()->json([
                'message' => 'File scan completed',
                'files_scanned' => count($validated['files']),
                'vulnerabilities_found' => $totalVulnerabilities,
                'scan_results' => $scanResults
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'File scan failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generate AI fix for vulnerability
     */
    public function generateFix(Request $request, string $id): JsonResponse
    {
        $vulnerability = $this->vulnerabilityRepository->findById($id);
        
        if (!$vulnerability) {
            return response()->json(['error' => 'Vulnerability not found'], 404);
        }

        try {
            // Get the vulnerable code
            $codeContent = $this->getVulnerableCode($vulnerability);
            
            // Send to AI service for fix generation
            $fixResult = $this->sendToAiFixService($codeContent, $vulnerability->identifier);
            
            // Store the AI fix
            $this->aiFixRepository->create([
                'id' => \Illuminate\Support\Str::uuid(),
                'vulnerability_id' => $vulnerability->id,
                'fixed_code' => $fixResult['fixed_code'],
                'confidence_score' => $fixResult['confidence'],
                'explanation' => $fixResult['explanation'],
                'recommendations' => $fixResult['recommendations'] ?? [],
                'status' => 'generated',
                'repository_id' => $vulnerability->repository_id
            ]);

            // Update vulnerability status
            $this->vulnerabilityRepository->update($id, ['status' => 'fixing']);

            return response()->json([
                'message' => 'AI fix generated successfully',
                'fix_id' => $fixResult['fix_id'],
                'confidence' => $fixResult['confidence'],
                'recommendations' => $fixResult['recommendations']
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'AI fix generation failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Apply AI fix to codebase
     */
    public function applyFix(Request $request, string $id): JsonResponse
    {
        $validated = $request->validate([
            'fix_id' => 'required|uuid',
            'create_pull_request' => 'boolean'
        ]);

        $vulnerability = $this->vulnerabilityRepository->findById($id);
        $fix = $this->aiFixRepository->findById($validated['fix_id']);

        if (!$vulnerability || !$fix) {
            return response()->json(['error' => 'Vulnerability or fix not found'], 404);
        }

        try {
            // Apply the fix to the codebase
            $result = $this->applyFixToCodebase($vulnerability, $fix);
            
            if ($validated['create_pull_request']) {
                // Create pull request
                $prUrl = $this->createPullRequest($vulnerability, $fix, $result);
                $result['pull_request_url'] = $prUrl;
            }

            // Update vulnerability status
            $this->vulnerabilityRepository->update($id, [
                'status' => 'fixed',
                'fixed_at' => now()
            ]);

            // Update fix status
            $this->aiFixRepository->update($validated['fix_id'], ['status' => 'applied']);

            return response()->json([
                'message' => 'Fix applied successfully',
                'result' => $result
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Fix application failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get vulnerability statistics
     */
    public function statistics(): JsonResponse
    {
        $stats = $this->vulnerabilityRepository->getStatistics();
        
        return response()->json([
            'total_vulnerabilities' => $stats['total'],
            'by_severity' => $stats['by_severity'],
            'by_status' => $stats['by_status'],
            'recent_detections' => $stats['recent'],
            'trend' => $stats['trend']
        ]);
    }

    private function mapSeverity(float $severityScore): string
    {
        if ($severityScore >= 9.0) {
            return 'critical';
        } elseif ($severityScore >= 7.0) {
            return 'high';
        } elseif ($severityScore >= 4.0) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    private function cloneRepository(string $url, string $branch): string
    {
        $repoName = basename($url, '.git');
        $repoPath = storage_path("app/temp/repos/{$repoName}_" . time());
        
        // Create directory if it doesn't exist
        if (!is_dir(dirname($repoPath))) {
            mkdir(dirname($repoPath), 0755, true);
        }
        
        // Clone repository with proper input sanitization
        $branch = escapeshellarg(trim($branch));
        $url = escapeshellarg(trim($url));
        $repoPath = escapeshellarg(trim($repoPath));
        
        exec("git clone --branch {$branch} {$url} {$repoPath} 2>&1", $output, $returnCode);
        
        if ($returnCode !== 0) {
            throw new \Exception("Failed to clone repository: " . implode("\n", $output));
        }
        
        return $repoPath;
    }

    private function scanCodeFiles(string $repoPath, string $scanType): array
    {
        $startTime = microtime(true);
        $vulnerabilities = [];
        $scanId = \Illuminate\Support\Str::uuid();
        
        // Find all code files
        $files = $this->findCodeFiles($repoPath);
        
        foreach ($files as $file) {
            $content = file_get_contents($file);
            $relativePath = str_replace($repoPath . '/', '', $file);
            
            // Send to AI service for scanning
            $result = $this->sendToAiService($content, $relativePath, $scanType);
            
            if (isset($result['vulnerability_analysis']['vulnerabilities'])) {
                foreach ($result['vulnerability_analysis']['vulnerabilities'] as $vulnerability) {
                    $vulnerability['file_path'] = $relativePath;
                    $vulnerabilities[] = $vulnerability;
                }
            }
        }
        
        return [
            'scan_id' => $scanId,
            'vulnerabilities' => $vulnerabilities,
            'duration' => round(microtime(true) - $startTime, 2)
        ];
    }

    private function findCodeFiles(string $path): array
    {
        $files = [];
        $extensions = ['php', 'js', 'ts', 'vue', 'py', 'java', 'cpp', 'c', 'h', 'go', 'rs'];
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($path),
            \RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), $extensions)) {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }

    private function sendToAiService(string $content, string $filename, string $scanType): array
    {
        // Create temporary file for the AI service
        $tempFile = tempnam(sys_get_temp_dir(), 'devguardian_scan_');
        file_put_contents($tempFile, $content);
        
        $response = Http::timeout(60)->attach(
            'file', file_get_contents($tempFile), $filename
        )->post(
            config('services.ai_service.url') . '/api/security/scan',
            [
                'scan_type' => $scanType
            ]
        );
        
        // Clean up temporary file
        unlink($tempFile);
        
        if (!$response->successful()) {
            throw new \Exception('AI service scan failed: ' . $response->body());
        }
        
        return $response->json();
    }

    private function sendToAiFixService(string $content, string $vulnerabilityType): array
    {
        // Create temporary file for the AI fix service
        $tempFile = tempnam(sys_get_temp_dir(), 'devguardian_fix_');
        file_put_contents($tempFile, $content);
        
        $response = Http::timeout(120)->attach(
            'file', file_get_contents($tempFile), 'vulnerable_code.php'
        )->post(
            config('services.ai_service.url') . '/api/ai-fix/generate-fix',
            [
                'vulnerability_type' => $vulnerabilityType
            ]
        );
        
        // Clean up temporary file
        unlink($tempFile);
        
        if (!$response->successful()) {
            throw new \Exception('AI fix service failed: ' . $response->body());
        }
        
        return $response->json();
    }

    private function getVulnerableCode($vulnerability): string
    {
        // Get code snippet from location data
        return $vulnerability->location['code_snippet'] ?? '';
    }

    private function applyFixToCodebase($vulnerability, $fix): array
    {
        $filePath = $vulnerability->location['path'] ?? '';
        if (!file_exists($filePath)) {
            throw new \Exception('Source file not found');
        }
        
        // Backup original file
        $backupPath = $filePath . '.backup.' . date('Y-m-d-H-i-s');
        copy($filePath, $backupPath);
        
        // Apply fix
        file_put_contents($filePath, $fix->fixed_code);
        
        return [
            'file_path' => $filePath,
            'backup_path' => $backupPath,
            'fix_applied' => true
        ];
    }

    private function createPullRequest($vulnerability, $fix, $result): string
    {
        // Mock implementation - integrate with GitHub/GitLab APIs
        $prTitle = "Fix: {$vulnerability->title}";
        $prDescription = "Automated fix for vulnerability {$vulnerability->id}\n\n" .
                        "**AI Confidence:** {$fix->confidence}%\n\n" .
                        "**Explanation:** {$fix->explanation}\n\n" .
                        "**Recommendations:**\n" . implode("\n", $fix->recommendations);
        
        // Return mock PR URL
        return "https://github.com/example/repo/pull/123";
    }

    private function cleanupRepository(string $repoPath): void
    {
        if (is_dir($repoPath)) {
            exec("rm -rf {$repoPath}");
        }
    }
}
