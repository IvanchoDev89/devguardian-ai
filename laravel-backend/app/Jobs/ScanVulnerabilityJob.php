<?php

namespace App\Jobs;

use App\Core\Domain\Repositories\VulnerabilityRepository;
use App\Core\Domain\Repositories\AiFixRepository;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;

class ScanVulnerabilityJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable;

    public function __construct(
        private string $repositoryId,
        private string $scanType = 'quick',
        private array $options = []
    ) {}

    public function handle(
        VulnerabilityRepository $vulnerabilityRepository,
        AiFixRepository $aiFixRepository
    ): void {
        try {
            // Get repository details
            $repository = app(\App\Core\Domain\Repositories\RepositoryRepository::class)->findById($this->repositoryId);
            
            if (!$repository) {
                \Log::error("Repository not found: {$this->repositoryId}");
                return;
            }

            // Clone repository
            $repoPath = $this->cloneRepository($repository->url, $repository->default_branch);
            
            // Scan files
            $scanResults = $this->scanCodeFiles($repoPath, $this->scanType);
            
            // Store vulnerabilities
            foreach ($scanResults['vulnerabilities'] as $vulnerability) {
                $vulnerabilityRepository->create([
                    'id' => \Illuminate\Support\Str::uuid(),
                    'repository_id' => $this->repositoryId,
                    'cve_id' => $vulnerability['cve_id'] ?? null,
                    'identifier' => $vulnerability['identifier'],
                    'title' => $vulnerability['title'],
                    'description' => $vulnerability['description'],
                    'severity' => $vulnerability['severity'],
                    'cvss_score' => $vulnerability['cvss_score'] ?? null,
                    'cvss_vector' => $vulnerability['cvss_vector'] ?? null,
                    'location' => $vulnerability['location'],
                    'status' => 'detected',
                    'metadata' => $vulnerability['metadata'] ?? [],
                    'detected_at' => now(),
                ]);
            }

            // Cleanup
            $this->cleanupRepository($repoPath);
            
            \Log::info("Vulnerability scan completed for repository {$this->repositoryId}", [
                'vulnerabilities_found' => count($scanResults['vulnerabilities']),
                'scan_duration' => $scanResults['duration']
            ]);

        } catch (\Exception $e) {
            \Log::error("Vulnerability scan failed for repository {$this->repositoryId}: " . $e->getMessage());
        }
    }

    private function cloneRepository(string $url, string $branch): string
    {
        $repoName = basename($url, '.git');
        $repoPath = storage_path("app/temp/repos/{$repoName}_" . time());
        
        if (!is_dir(dirname($repoPath))) {
            mkdir(dirname($repoPath), 0755, true);
        }
        
        // Validate and sanitize inputs
        $branch = escapeshellarg(trim($branch));
        $url = escapeshellarg(trim($url));
        $repoPath = escapeshellarg(trim($repoPath));
        
        // Clone repository with security measures
        $command = "git clone --branch {$branch} {$url} {$repoPath} 2>&1";
        exec($command, $output, $returnCode);
        
        if ($returnCode !== 0) {
            throw new \Exception("Failed to clone repository: " . implode("\n", $output));
        }
        
        return $repoPath;
    }

    private function scanCodeFiles(string $repoPath, string $scanType): array
    {
        $startTime = microtime(true);
        $vulnerabilities = [];
        
        $files = $this->findCodeFiles($repoPath);
        
        foreach ($files as $file) {
            $content = file_get_contents($file);
            $relativePath = str_replace($repoPath . '/', '', $file);
            
            $result = $this->sendToAiService($content, $relativePath, $scanType);
            
            if (isset($result['vulnerability_analysis']['vulnerabilities'])) {
                foreach ($result['vulnerability_analysis']['vulnerabilities'] as $vulnerability) {
                    $vulnerability['file_path'] = $relativePath;
                    $vulnerabilities[] = $vulnerability;
                }
            }
        }
        
        return [
            'vulnerabilities' => $vulnerabilities,
            'duration' => round(microtime(true) - $startTime, 2)
        ];
    }

    private function findCodeFiles(string $path): array
    {
        $files = [];
        $extensions = ['php', 'js', 'ts', 'vue', 'py', 'java', 'cpp', 'c', 'h', 'go', 'rs'];
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($path),
            \RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), $extensions)) {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }

    private function sendToAiService(string $content, string $filename, string $scanType): array
    {
        $response = Http::timeout(60)->post(
            config('services.ai_service.url') . '/api/security/scan',
            [
                'content' => $content,
                'filename' => $filename,
                'deep_scan' => $scanType === 'deep'
            ]
        );
        
        if (!$response->successful()) {
            throw new \Exception('AI service scan failed: ' . $response->body());
        }
        
        return $response->json();
    }

    private function cleanupRepository(string $repoPath): void
    {
        if (is_dir($repoPath)) {
            exec("rm -rf {$repoPath}");
        }
    }
}
