<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Core\Application\Services\AiRemediationService;
use App\Core\Application\Services\GitIntegrationService;
use App\Core\Domain\Vulnerabilities\Vulnerability;
use App\Core\Domain\AiFixes\AiFix;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

final class ProcessVulnerabilityJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $timeout = 300; // 5 minutes
    public int $tries = 3;
    public int|array $backoff = [60, 180, 300]; // Exponential backoff

    public function __construct(
        private readonly Vulnerability $vulnerability,
        private readonly array $options = []
    ) {
        $this->onQueue('ai-processing');
    }

    public function handle(
        AiRemediationService $aiService,
        GitIntegrationService $gitService
    ): void {
        Log::info('Starting vulnerability processing job', [
            'vulnerability_id' => $this->vulnerability->id,
            'repository_id' => $this->vulnerability->repository_id,
            'job_id' => $this->job->getJobId()
        ]);

        try {
            // Check if vulnerability still needs processing
            if (!$this->vulnerability->canBeFixed()) {
                Log::info('Vulnerability no longer needs processing', [
                    'vulnerability_id' => $this->vulnerability->id,
                    'status' => $this->vulnerability->status->value
                ]);
                return;
            }

            // Generate AI fix
            $aiFix = $aiService->generateFixForVulnerability($this->vulnerability);

            if (!$aiFix) {
                Log::warning('AI fix generation failed', [
                    'vulnerability_id' => $this->vulnerability->id
                ]);
                return;
            }

            // Create pull request if fix is successful and auto-PR is enabled
            if ($aiFix->isSuccessful() && ($this->options['auto_pr'] ?? false)) {
                $this->createPullRequest($gitService, $aiFix);
            }

            // Send notifications if enabled
            if ($this->options['notify'] ?? true) {
                $this->sendNotifications($aiFix);
            }

            Log::info('Vulnerability processing completed successfully', [
                'vulnerability_id' => $this->vulnerability->id,
                'fix_id' => $aiFix->id,
                'confidence_score' => $aiFix->confidence_score
            ]);

        } catch (\Exception $e) {
            Log::error('Vulnerability processing job failed', [
                'vulnerability_id' => $this->vulnerability->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            $this->fail($e);
        }
    }

    private function createPullRequest(GitIntegrationService $gitService, AiFix $aiFix): void
    {
        try {
            $repository = $aiFix->repository;
            $prOptions = [
                'title' => "Security Fix: {$aiFix->vulnerability->title}",
                'draft' => $aiFix->confidence_score < 0.8 // Low confidence fixes as drafts
            ];

            $pr = $gitService->createPullRequest($repository, $aiFix, $prOptions);

            Log::info('Pull request created successfully', [
                'fix_id' => $aiFix->id,
                'pr_url' => $pr['html_url'] ?? $pr['web_url'] ?? null,
                'pr_number' => $pr['number'] ?? $pr['iid'] ?? null
            ]);

            // Update AI fix with PR information
            $aiFix->update([
                'status' => 'applied',
                'metadata' => array_merge($aiFix->metadata ?? [], [
                    'pull_request_created_at' => now()->toISOString(),
                    'auto_pr' => true
                ])
            ]);

        } catch (\Exception $e) {
            Log::error('Failed to create pull request', [
                'fix_id' => $aiFix->id,
                'error' => $e->getMessage()
            ]);

            // Don't fail the job, just log the error
            $aiFix->update([
                'metadata' => array_merge($aiFix->metadata ?? [], [
                    'pr_creation_failed' => true,
                    'pr_error' => $e->getMessage()
                ])
            ]);
        }
    }

    private function sendNotifications(AiFix $aiFix): void
    {
        try {
            $vulnerability = $aiFix->vulnerability;
            $repository = $vulnerability->repository;
            $organization = $repository->organization;

            // Send different notifications based on severity and confidence
            if ($vulnerability->isCritical() && $aiFix->isHighConfidence()) {
                // High priority notification for critical vulnerabilities
                $this->sendHighPriorityNotification($aiFix);
            } elseif ($aiFix->isSuccessful()) {
                // Standard notification for successful fixes
                $this->sendStandardNotification($aiFix);
            } else {
                // Low priority notification for failed fixes
                $this->sendLowPriorityNotification($aiFix);
            }

        } catch (\Exception $e) {
            Log::error('Failed to send notifications', [
                'fix_id' => $aiFix->id,
                'error' => $e->getMessage()
            ]);
        }
    }

    private function sendHighPriorityNotification(AiFix $aiFix): void
    {
        // Implementation for high priority notifications
        // Could include Slack, email, SMS, etc.
        Log::info('High priority notification sent', [
            'fix_id' => $aiFix->id,
            'type' => 'high_priority'
        ]);
    }

    private function sendStandardNotification(AiFix $aiFix): void
    {
        // Implementation for standard notifications
        Log::info('Standard notification sent', [
            'fix_id' => $aiFix->id,
            'type' => 'standard'
        ]);
    }

    private function sendLowPriorityNotification(AiFix $aiFix): void
    {
        // Implementation for low priority notifications
        Log::info('Low priority notification sent', [
            'fix_id' => $aiFix->id,
            'type' => 'low_priority'
        ]);
    }

    public function failed(\Throwable $exception): void
    {
        Log::error('Vulnerability processing job failed permanently', [
            'vulnerability_id' => $this->vulnerability->id,
            'error' => $exception->getMessage(),
            'attempts' => $this->attempts()
        ]);

        // Update vulnerability status to indicate processing failure
        $this->vulnerability->update(['status' => 'detected']);
    }

    public function tags(): array
    {
        return [
            'process-vulnerability',
            'vulnerability:' . $this->vulnerability->id,
            'repository:' . $this->vulnerability->repository_id,
            'organization:' . $this->vulnerability->repository->organization_id,
            'severity:' . $this->vulnerability->severity->value
        ];
    }
}
