<?php

declare(strict_types=1);

namespace App\Core\Domain\Vulnerabilities;

use App\Core\Domain\Repositories\Repository;
use App\Core\Domain\ValueObjects\CVSSScore;
use App\Core\Domain\ValueObjects\FileLocation;
use App\Core\Domain\AiFixes\AiFix;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

enum VulnerabilityStatus: string
{
    case DETECTED = 'detected';
    case ANALYZING = 'analyzing';
    case FIXING = 'fixing';
    case FIXED = 'fixed';
    case IGNORED = 'ignored';
    case FALSE_POSITIVE = 'false_positive';
}

enum VulnerabilitySeverity: string
{
    case NONE = 'none';
    case LOW = 'low';
    case MEDIUM = 'medium';
    case HIGH = 'high';
    case CRITICAL = 'critical';
}

final class Vulnerability extends Model
{
    use HasFactory;

    protected $fillable = [
        'repository_id',
        'cve_id',
        'identifier',
        'title',
        'description',
        'severity',
        'cvss_score',
        'cvss_vector',
        'location',
        'status',
        'metadata',
        'detected_at',
        'fixed_at'
    ];

    protected $casts = [
        'id' => 'string',
        'repository_id' => 'string',
        'cvss_score' => 'decimal:1',
        'location' => 'array',
        'status' => VulnerabilityStatus::class,
        'severity' => VulnerabilitySeverity::class,
        'metadata' => 'array',
        'detected_at' => 'datetime',
        'fixed_at' => 'datetime'
    ];

    public function repository(): BelongsTo
    {
        return $this->belongsTo(Repository::class);
    }

    public function aiFixes(): HasMany
    {
        return $this->hasMany(AiFix::class);
    }

    public function getCVSSScore(): CVSSScore
    {
        return new CVSSScore(
            score: (float) $this->cvss_score,
            vector: $this->cvss_vector
        );
    }

    public function getFileLocation(): FileLocation
    {
        $location = $this->location;
        
        return new FileLocation(
            filePath: $location['file_path'] ?? '',
            lineNumber: $location['line_number'] ?? 1,
            columnNumber: $location['column_number'] ?? null,
            functionName: $location['function_name'] ?? null,
            className: $location['class_name'] ?? null
        );
    }

    public function isCritical(): bool
    {
        return $this->severity === VulnerabilitySeverity::CRITICAL || 
               ($this->cvss_score && $this->cvss_score >= 9.0);
    }

    public function isHigh(): bool
    {
        return $this->severity === VulnerabilitySeverity::HIGH || 
               ($this->cvss_score && $this->cvss_score >= 7.0 && $this->cvss_score < 9.0);
    }

    public function isFixed(): bool
    {
        return $this->status === VulnerabilityStatus::FIXED;
    }

    public function isBeingFixed(): bool
    {
        return in_array($this->status, [VulnerabilityStatus::ANALYZING, VulnerabilityStatus::FIXING]);
    }

    public function canBeFixed(): bool
    {
        return !in_array($this->status, [
            VulnerabilityStatus::FIXED,
            VulnerabilityStatus::IGNORED,
            VulnerabilityStatus::FALSE_POSITIVE
        ]);
    }

    public function markAsAnalyzing(): void
    {
        $this->status = VulnerabilityStatus::ANALYZING;
        $this->save();
    }

    public function markAsFixing(): void
    {
        $this->status = VulnerabilityStatus::FIXING;
        $this->save();
    }

    public function markAsFixed(): void
    {
        $this->status = VulnerabilityStatus::FIXED;
        $this->fixed_at = now();
        $this->save();
    }

    public function markAsIgnored(): void
    {
        $this->status = VulnerabilityStatus::IGNORED;
        $this->save();
    }

    public function markAsFalsePositive(): void
    {
        $this->status = VulnerabilityStatus::FALSE_POSITIVE;
        $this->save();
    }

    public function getLatestAiFix(): ?AiFix
    {
        return $this->aiFixes()->latest()->first();
    }

    public function hasSuccessfulAiFix(): bool
    {
        return $this->aiFixes()->where('status', 'validated')->exists();
    }

    public function getTimeToRemediation(): ?\DateInterval
    {
        if (!$this->fixed_at) {
            return null;
        }

        return $this->detected_at->diff($this->fixed_at);
    }

    public function getTimeToRemediationInHours(): ?float
    {
        $interval = $this->getTimeToRemediation();
        
        if (!$interval) {
            return null;
        }

        return ($interval->days * 24) + $interval->h + ($interval->i / 60);
    }

    public function getMetadata(string $key, mixed $default = null): mixed
    {
        return data_get($this->metadata, $key, $default);
    }

    public function setMetadata(string $key, mixed $value): void
    {
        $this->metadata = array_merge($this->metadata ?? [], [$key => $value]);
    }

    public function scopeCritical($query)
    {
        return $query->where('severity', VulnerabilitySeverity::CRITICAL)
            ->orWhere('cvss_score', '>=', 9.0);
    }

    public function scopeHigh($query)
    {
        return $query->where('severity', VulnerabilitySeverity::HIGH)
            ->orWhereBetween('cvss_score', [7.0, 8.9]);
    }

    public function scopeUnfixed($query)
    {
        return $query->whereNotIn('status', [
            VulnerabilityStatus::FIXED,
            VulnerabilityStatus::IGNORED,
            VulnerabilityStatus::FALSE_POSITIVE
        ]);
    }

    public function scopeByStatus($query, VulnerabilityStatus $status)
    {
        return $query->where('status', $status);
    }

    public function scopeBySeverity($query, VulnerabilitySeverity $severity)
    {
        return $query->where('severity', $severity);
    }
}
