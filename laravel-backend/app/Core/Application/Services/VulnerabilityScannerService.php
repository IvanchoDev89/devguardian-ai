<?php

declare(strict_types=1);

namespace App\Core\Application\Services;

use App\Core\Domain\Repositories\Repository;
use App\Core\Domain\Vulnerabilities\Vulnerability;
use App\Core\Domain\Vulnerabilities\VulnerabilityStatus;
use App\Core\Domain\Vulnerabilities\VulnerabilitySeverity;
use App\Core\Domain\ValueObjects\CVSSScore;
use App\Core\Domain\ValueObjects\FileLocation;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Collection;
use Exception;

final class VulnerabilityScannerService
{
    private const SNYK_API_BASE = 'https://api.snyk.io/v1';
    private const TRIVY_API_BASE = 'http://trivy:8080';
    private const GITHUB_API_BASE = 'https://api.github.com';

    public function __construct(
        private readonly string $snykToken,
        private readonly string $githubToken
    ) {}

    public function scanRepository(Repository $repository): Collection
    {
        Log::info('Starting repository scan', [
            'repository_id' => $repository->id,
            'repository_url' => $repository->url
        ]);

        $vulnerabilities = collect();

        try {
            // Scan dependencies
            $dependencyVulnerabilities = $this->scanDependencies($repository);
            $vulnerabilities = $vulnerabilities->merge($dependencyVulnerabilities);

            // Scan code for security issues
            $codeVulnerabilities = $this->scanCode($repository);
            $vulnerabilities = $vulnerabilities->merge($codeVulnerabilities);

            // Scan container images if configured
            if ($repository->getScanSetting('scan_containers', false)) {
                $containerVulnerabilities = $this->scanContainers($repository);
                $vulnerabilities = $vulnerabilities->merge($containerVulnerabilities);
            }

            // Update last scanned timestamp
            $repository->update(['last_scanned_at' => now()]);

            Log::info('Repository scan completed', [
                'repository_id' => $repository->id,
                'vulnerabilities_found' => $vulnerabilities->count()
            ]);

            return $vulnerabilities;

        } catch (Exception $e) {
            Log::error('Repository scan failed', [
                'repository_id' => $repository->id,
                'error' => $e->getMessage()
            ]);
            throw $e;
        }
    }

    private function scanDependencies(Repository $repository): Collection
    {
        $vulnerabilities = collect();
        $gitUrl = $repository->getGitRepositoryUrl();

        try {
            // Clone repository temporarily
            $tempPath = $this->cloneRepositoryTemporarily($gitUrl);

            // Scan different dependency files
            $dependencyFiles = [
                'composer.json' => 'php',
                'package.json' => 'javascript',
                'requirements.txt' => 'python',
                'Gemfile' => 'ruby',
                'pom.xml' => 'java',
                'go.mod' => 'go'
            ];

            foreach ($dependencyFiles as $file => $language) {
                $filePath = $tempPath . '/' . $file;
                if (file_exists($filePath)) {
                    $fileVulnerabilities = $this->scanDependencyFile($filePath, $language, $repository);
                    $vulnerabilities = $vulnerabilities->merge($fileVulnerabilities);
                }
            }

            // Clean up temporary directory
            $this->cleanupTempDirectory($tempPath);

        } catch (Exception $e) {
            Log::error('Dependency scan failed', [
                'repository_id' => $repository->id,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function scanDependencyFile(string $filePath, string $language, Repository $repository): Collection
    {
        $vulnerabilities = collect();

        try {
            // Use Snyk for dependency scanning
            if (!empty($this->snykToken)) {
                $snykVulnerabilities = $this->scanWithSnyk($filePath, $language);
                $vulnerabilities = $vulnerabilities->merge($snykVulnerabilities);
            }

            // Use GitHub Advisory Database as backup
            $githubVulnerabilities = $this->scanWithGitHubAdvisory($filePath, $language);
            $vulnerabilities = $vulnerabilities->merge($githubVulnerabilities);

        } catch (Exception $e) {
            Log::error('Dependency file scan failed', [
                'file_path' => $filePath,
                'language' => $language,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function scanWithSnyk(string $filePath, string $language): Collection
    {
        $vulnerabilities = collect();

        try {
            $response = Http::withToken($this->snykToken)
                ->post(self::SNYK_API_BASE . '/test', [
                    'files' => [$filePath],
                    'type' => 'cli'
                ]);

            if (!$response->successful()) {
                throw new Exception('Snyk API request failed: ' . $response->status());
            }

            $data = $response->json();
            
            foreach ($data['vulnerabilities'] ?? [] as $vuln) {
                $vulnerability = $this->createVulnerabilityFromSnykData($vuln, $filePath, $language);
                $vulnerabilities->push($vulnerability);
            }

        } catch (Exception $e) {
            Log::warning('Snyk scan failed', [
                'file_path' => $filePath,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function scanWithGitHubAdvisory(string $filePath, string $language): Collection
    {
        $vulnerabilities = collect();

        try {
            // Parse dependency file
            $dependencies = $this->parseDependencyFile($filePath, $language);

            foreach ($dependencies as $package => $version) {
                $advisories = $this->queryGitHubAdvisory($package, $language);
                
                foreach ($advisories as $advisory) {
                    if ($this->isVersionAffected($version, $advisory['vulnerable_versions'])) {
                        $vulnerability = $this->createVulnerabilityFromGitHubAdvisory($advisory, $package, $version, $filePath);
                        $vulnerabilities->push($vulnerability);
                    }
                }
            }

        } catch (Exception $e) {
            Log::warning('GitHub Advisory scan failed', [
                'file_path' => $filePath,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function scanCode(Repository $repository): Collection
    {
        $vulnerabilities = collect();

        try {
            $gitUrl = $repository->getGitRepositoryUrl();
            $tempPath = $this->cloneRepositoryTemporarily($gitUrl);

            // Use Trivy for code scanning
            $trivyVulnerabilities = $this->scanWithTrivy($tempPath, $repository);
            $vulnerabilities = $vulnerabilities->merge($trivyVulnerabilities);

            // Custom security rules
            $customVulnerabilities = $this->applyCustomSecurityRules($tempPath, $repository);
            $vulnerabilities = $vulnerabilities->merge($customVulnerabilities);

            $this->cleanupTempDirectory($tempPath);

        } catch (Exception $e) {
            Log::error('Code scan failed', [
                'repository_id' => $repository->id,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function scanWithTrivy(string $tempPath, Repository $repository): Collection
    {
        $vulnerabilities = collect();

        try {
            $response = Http::post(self::TRIVY_API_BASE . '/scan', [
                'target' => $tempPath,
                'scanners' => ['vuln', 'secret', 'misconfig'],
                'format' => 'json'
            ]);

            if (!$response->successful()) {
                throw new Exception('Trivy scan failed: ' . $response->status());
            }

            $results = $response->json();
            
            foreach ($results['Results'] ?? [] as $result) {
                foreach ($result['Vulnerabilities'] ?? [] as $vuln) {
                    $vulnerability = $this->createVulnerabilityFromTrivyData($vuln, $repository);
                    $vulnerabilities->push($vulnerability);
                }
            }

        } catch (Exception $e) {
            Log::warning('Trivy scan failed', [
                'repository_id' => $repository->id,
                'error' => $e->getMessage()
            ]);
        }

        return $vulnerabilities;
    }

    private function applyCustomSecurityRules(string $tempPath, Repository $repository): Collection
    {
        $vulnerabilities = collect();

        // Scan for hardcoded secrets
        $secrets = $this->scanForSecrets($tempPath);
        $vulnerabilities = $vulnerabilities->merge($secrets);

        // Scan for SQL injection patterns
        $sqlInjections = $this->scanForSqlInjection($tempPath);
        $vulnerabilities = $vulnerabilities->merge($sqlInjections);

        // Scan for XSS patterns
        $xssVulnerabilities = $this->scanForXSS($tempPath);
        $vulnerabilities = $vulnerabilities->merge($xssVulnerabilities);

        return $vulnerabilities;
    }

    private function scanForSecrets(string $tempPath): Collection
    {
        $vulnerabilities = collect();
        $secretPatterns = [
            '/password\s*=\s*["\']([^"\']+)["\']/i',
            '/api_key\s*=\s*["\']([^"\']+)["\']/i',
            '/secret\s*=\s*["\']([^"\']+)["\']/i',
            '/token\s*=\s*["\']([^"\']+)["\']/i'
        ];

        $files = $this->getSourceFiles($tempPath);

        foreach ($files as $file) {
            $content = file_get_contents($file);
            $lines = file($file, FILE_IGNORE_NEW_LINES);

            foreach ($secretPatterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE)) {
                    foreach ($matches[0] as $match) {
                        $lineNumber = $this->getLineNumberForPosition($content, $match[1]);
                        
                        $vulnerability = new Vulnerability([
                            'repository_id' => $repository->id,
                            'identifier' => 'HARDCODED_SECRET_' . md5($match[0]),
                            'title' => 'Hardcoded Secret Detected',
                            'description' => 'A hardcoded secret or credential was found in the source code.',
                            'severity' => VulnerabilitySeverity::HIGH,
                            'cvss_score' => 7.5,
                            'location' => [
                                'file_path' => str_replace($tempPath . '/', '', $file),
                                'line_number' => $lineNumber,
                                'column_number' => $match[1] - strpos($content, $lines[$lineNumber - 1])
                            ],
                            'status' => VulnerabilityStatus::DETECTED,
                            'detected_at' => now(),
                            'metadata' => [
                                'scanner' => 'custom',
                                'pattern' => $pattern,
                                'matched_text' => $match[0]
                            ]
                        ]);

                        $vulnerabilities->push($vulnerability);
                    }
                }
            }
        }

        return $vulnerabilities;
    }

    private function scanForSqlInjection(string $tempPath): Collection
    {
        // Implementation for SQL injection scanning
        return collect();
    }

    private function scanForXSS(string $tempPath): Collection
    {
        // Implementation for XSS scanning
        return collect();
    }

    private function cloneRepositoryTemporarily($gitUrl): string
    {
        $tempPath = sys_get_temp_dir() . '/devguardian_scan_' . uniqid();
        
        exec("git clone {$gitUrl->getCloneUrl()} {$tempPath} 2>&1", $output, $returnCode);
        
        if ($returnCode !== 0) {
            throw new Exception('Failed to clone repository: ' . implode("\n", $output));
        }

        return $tempPath;
    }

    private function cleanupTempDirectory(string $tempPath): void
    {
        exec("rm -rf {$tempPath}");
    }

    private function getSourceFiles(string $tempPath): array
    {
        $files = [];
        $extensions = ['php', 'js', 'ts', 'py', 'java', 'go', 'rb', 'cs'];
        
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($tempPath, RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), $extensions)) {
                $files[] = $file->getPathname();
            }
        }

        return $files;
    }

    private function getLineNumberForPosition(string $content, int $position): int
    {
        $before = substr($content, 0, $position);
        return substr_count($before, "\n") + 1;
    }

    private function createVulnerabilityFromSnykData(array $data, string $filePath, string $language): Vulnerability
    {
        return new Vulnerability([
            'identifier' => $data['id'],
            'title' => $data['title'],
            'description' => $data['description'],
            'severity' => VulnerabilitySeverity::from(strtolower($data['severity'])),
            'cvss_score' => $data['cvssScore'] ?? null,
            'cvss_vector' => $data['cvssVector'] ?? null,
            'location' => [
                'file_path' => basename($filePath),
                'line_number' => 1
            ],
            'status' => VulnerabilityStatus::DETECTED,
            'detected_at' => now(),
            'metadata' => [
                'scanner' => 'snyk',
                'language' => $language,
                'package' => $data['package'] ?? null,
                'version' => $data['version'] ?? null
            ]
        ]);
    }

    private function createVulnerabilityFromGitHubAdvisory(array $advisory, string $package, string $version, string $filePath): Vulnerability
    {
        return new Vulnerability([
            'cve_id' => $advisory['cve_id'] ?? null,
            'identifier' => $advisory['ghsa_id'],
            'title' => $advisory['summary'],
            'description' => $advisory['description'],
            'severity' => VulnerabilitySeverity::from(strtolower($advisory['severity'])),
            'location' => [
                'file_path' => basename($filePath),
                'line_number' => 1
            ],
            'status' => VulnerabilityStatus::DETECTED,
            'detected_at' => now(),
            'metadata' => [
                'scanner' => 'github_advisory',
                'package' => $package,
                'version' => $version,
                'ghsa_id' => $advisory['ghsa_id']
            ]
        ]);
    }

    private function createVulnerabilityFromTrivyData(array $data, Repository $repository): Vulnerability
    {
        return new Vulnerability([
            'identifier' => $data['VulnerabilityID'],
            'title' => $data['Title'],
            'description' => $data['Description'],
            'severity' => VulnerabilitySeverity::from(strtolower($data['Severity'])),
            'cvss_score' => $data['CVSS']['nvd']['V3Score'] ?? null,
            'cvss_vector' => $data['CVSS']['nvd']['V3Vector'] ?? null,
            'location' => [
                'file_path' => $data['PkgName'] ?? 'unknown',
                'line_number' => 1
            ],
            'status' => VulnerabilityStatus::DETECTED,
            'detected_at' => now(),
            'metadata' => [
                'scanner' => 'trivy',
                'package' => $data['PkgName'] ?? null,
                'version' => $data['InstalledVersion'] ?? null,
                'references' => $data['References'] ?? []
            ]
        ]);
    }
}
